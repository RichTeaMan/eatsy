apply plugin: 'java'
apply plugin: 'com.github.kt3k.coveralls'
apply plugin: 'jacoco'

//Java utilities/helper libraries
ext.commonsLang3Version = '3.12.0'
ext.lombokVersion = '1.18.24'

//coveralls
ext.coverallsVersion = '2.12.0'

//Java faker (for test data generation)
ext.javaFakerVersion = '1.0.2'

//test
ext.junitVersion = '5.8.2'
ext.mockitoCoreVersion = '4.6.0'
ext.byteBuddyVersion = '1.12.10'
ext.springStarterTestVersion = '2.7.0'
ext.equalsVerifierVersion = '3.10'
ext.toStringVerifierVersion = '1.4.8'
ext.assertJVersion = '3.22.0'

//spring
ext.springBootVersion = '2.7.0'
ext.springDocVersion = '1.6.9'

//Spring/Dependency Injection
ext.springContextVersion = '5.3.20'

//Logging
ext.log4jCoreVersion = '2.17.2'
ext.log4jApiVersion = '2.17.2'

allprojects {
    repositories {
        mavenCentral()
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'jacoco'

    repositories {
        mavenCentral()
    }

    test {
        useJUnitPlatform()
        testLogging {
            events "PASSED", "SKIPPED", "FAILED"
        }
    }

}

buildscript {
    ext {
        springBootGradlePluginVersion = '2.7.0'
    }
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }

    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:$springBootGradlePluginVersion"
        classpath "gradle.plugin.org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.12.0"
    }
}

//Heroku deployment configuration
task stage(type: Copy, dependsOn: [clean, build]) {
    from jar.archivePath
    into project.rootDir
    rename {
        'app.jar'
    }
}
stage.mustRunAfter(clean)

clean {
    project.file('app.jar').delete()
}

jar {
    manifest {
        attributes(
                'Main-Class': 'eatsyAppService-controller.org.eatsy.appservice.controller.application.ServerRunner'
        )
    }
}

//JaCoCo and coveralls configuration
def allTestCoverageFile = "$buildDir/jacoco/allTestCoverage.exec"
def devProjects = subprojects.findAll { it.path != 'test' } //Exclude test code projects

task jacocoMerge(type: JacocoMerge) {
    devProjects.each { subproject ->
        executionData subproject.tasks.withType(Test)
    }
    doFirst {
        executionData = files(executionData.findAll { it.exists() })
    }
    destinationFile = file(allTestCoverageFile)
}

task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
    description = 'Generates an aggregate report from all subprojects'
    dependsOn devProjects.test, jacocoMerge

    getAdditionalSourceDirs().setFrom(files(devProjects.sourceSets.main.allSource.srcDirs))
    getSourceDirectories().setFrom(files(devProjects.sourceSets.main.allSource.srcDirs))
    getClassDirectories().setFrom(files(devProjects.sourceSets.main.output))
    executionData jacocoMerge.destinationFile

    reports {
        html.required = true // human readable
        xml.required = true // required by coveralls
    }
}

coveralls {
    sourceDirs = devProjects.sourceSets.main.allSource.srcDirs.flatten()
    jacocoReportPath = "${buildDir}/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
}

tasks.coveralls {
    group = 'Coverage reports'
    description = 'Uploads the aggregated coverage report to Coveralls'
    dependsOn jacocoRootReport
}
